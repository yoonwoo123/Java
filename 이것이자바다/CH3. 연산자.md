# CH3. 연산자

## 3.1 연산자와 연산식

- 데이터를 처리하여 결과를 산출하는 것
- 연산자(Operations): 연산에 사용되는 표시나 기호(+, -, *, /, %, = ,...)

- 피연산자(Operand): 연산 대상이 되는 데이터(리터럴, 변수)

- 연산식(Expressions): 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것

- 연산자의 종류

  - 자바스크립트와 대부분이 동일하므로 따로 정리는 x

  

## 3.2 연산의 방향과 우선순위

### 연산의 방향과 우선 순위

- 연산자의 우선 순위에 따라 연산된다.
- 동일한 우선 순위의 연산자는 연산의 방향이 있다.
  - *, /, % 연산 방향이 **왼쪽에서 오른쪽**으로 수행된다.

- 하지만 단항 연산자(++, --, ~, !), 부호 연산자(+, -), 대입 연산자(=, +=, -=, ...)는 **오른쪽에서 왼쪽**으로 연산된다.
  - 이건 딱히 외우기 보다는 개발이나 알고리즘을 풀면서 체득되는 것 같다.
- 괄호 () 는 최우선 순위



## 3.3 단항 연산자

- 피연산자가 1개인 연산자

  - 종류

    - 부호 연산자: +, -
    - 증감 연산자: ++, --
    - 부정 연산자: !
    - 비트 반전 연산자: ~

  - 부호 연산자 +, -

    - +: 피연산자의 부호 유지
    - -: 피연산자의 부호 변경

    - boolean 타입과 char 타입을 제외한 기본 타입에 사용 가능

    - ```java
      short s = 100;
      short result = -100 // 컴파일 에러가 발생 
      // 왜냐하면 연산할때 short는 int로 변환되기 때문이다.
      ```

    

  - 증감 연산자: ++, --

    - 증감 연산자가 피연산자 앞에 오면 **다른 연산을 수행하기 전에 피연산자의 값을 변경**
    - 증감 연산자가 피연산자 뒤에 오면 **다른 연산을 수행한 후에 피연산자의 값을 변경**

    

  - 논리 부정 연산자 !

    - **boolean 타입만 피연산자가 될 수 있다.**

    

  - 비트 반전 연산자: ~

    - byte, short, int, long 타입만 피연산자가 될 수 있다.

    - 비트값을 반전(0 -> 1, 1 -> 0)시킨다.

    - 부호 비트인 최상위 비트까지 반전되므로 부호가 반대인 새로운 값이 산출된다.

    - 피연산자의 타입이 int 이하이면 연산의 결과는 int 타입이다.

      ```java
      byte v1 = 10;
      byte v2 = ~v1; //컴파일 에러
      
      byte v1 = 10;
      int v2 = ~v1; // 성공
      ```

    - 비트 반전후 1을 더하면 부호가 반대인 값을 얻을 수 있다.

      ```java
      byte v1 = 10;
      int v2 = ~v1 + 1; // -10이 v2에 저장
      ```



## 3.4 이항 연산자

- 오버플로우로 인해 잘못된 값이 산출되는 것을 방지

  - try, catch 구문으로 잘못된 값이 나오게 될 경우 에러를 발생시키자.

  - 이 부분은 나중에 다시 한번 보자

     

- 정확한 계산은 정수를 사용

  - 정확하게 계산해야할 때는 부동소수점(실수) 타입을 사용하지 않는 것이 좋다.

    ```java
    int apple = 1;
    double pieceUnit = 0.1;
    int number = 7;
    
    double result = apple - number * pieceUnit
        
    System.out.println("사과 한개에서 ");
    System.out.println("0.7 조각을 빼면, ");
    System.out.println(result + " 조각이 남는다.");
    
    /* 실행 결과
    사과 한개에서
    0.7 조각을 빼면
    0.29999999999999999993 조각이 남는다.
    이유는 java에서는 0.1을 정확히 표현하지 못하기 때문이다. 이를 해결하기 위해서
    */
    
    int apple = 1;
    
    // 소수점이 발생하지 않게 10을 곱해서 계산 후 10으로 나눠주자.
    int totalPieces = apple * 10; 
    int number = 7;
    int temp = totalPieces - number;
    
    double result = temp/10.0;
        
    System.out.println("사과 한개에서 ");
    System.out.println("0.7 조각을 빼면, ");
    System.out.println(result + " 조각이 남는다.");
    
    /* 실행 결과
    사과 한개에서
    0.7 조각을 빼면
    0.3 조각이 남는다.
    */
    ```

- NaN과 Infinity 연산을 조심, 조건문과 함수(Double.isInfinite(), Double.isNaN() 로 검사)

  ```java
  // 둘 다 정수일 경우 수학적으로 말이 안되므로 예외 발생
  5 / 0 -> ArithmeticException 예외 발생
  5 % 0 -> ArithmeticException 예외 발생
      
  // 둘 중 하나라도 실수일 경우 무한대 or NaN이 할당된다. 즉 오류가 나지 않는다!
  // 그래서 올바른 연산을 할 수 있도록 값을 반드시 확인해야 한다.
  5 / 0.0 -> Infinity
  5 % 0.0 -> NaN
  
  Infinity + 2 -> Infinity
  NaN + 2 -> NaN
  ```



- 입력된 문자열을 숫자로 변환할 때 NaN인지 검사
  - 조건문과 함수(Double.isNaN())로 NaN인지 검사



- 문자열 연결 연산자(+)

  - 피연산자중 문자열이 있으면 문자열로 결합시킨다.

    

- 비교 연산자(==, !=, <, >, <=, >=)

  - 동등 비교 연산자는 모든 타입에 사용
  - 크기 비교 연산자는 boolean 타입을 제외한 모든 기본 타입에 사용
  - 흐름 제어문인 조건문, 반복문에서 주로 사용

  

  - 문자열 비교

    - String 타입의 문자열을 비교할 때에는 대소 연산자를 사용할 수 없다.

    - 동등, 비교 연산자는 사용할 수 있으나, 문자열이 같은지, 다른지를 비교하는 용도로는 사용하지 않는다.

    - **문자열 비교는 equals() 메소드를 사용해야 한다.**

      ```java
      String strVar1 = "신용권";
      String strVar2 = "신용권";
      String strVar3 = new String("신용권");
      
      /* 여기서 리터럴로 선언한 변수 1, 2는 같은 주소값(번지값)을 가지고 있으나
      new 생성자로 선언한 변수 3은 1, 2와는 다른 주소값을 가지고 있다.
      따라서 단순 글자가 같은지의 비교를 하고 싶은데 비교 연산자는 주소값을 비교하기 때문에
      원하는 동작을 수행할 수 없고 equals() 메소드를 사용해야 올바르게 구할 수 있다! */
      ```

    

- 논리 연산자 (&&, ||, &, |, ^, !)

  - 논리곱(&&), 논리합(||), 배타적 논리합(^) 그리고 논리 부정(!) 연산을 수행

  - 피연산자는 boolean 타입만 사용할 수 있다.

  - **&&와 &는 산출 결과는 같지만 연산 과정이 조금 다르다.** **&&는 앞의 피연산자가 false라면 뒤의 연산자를 평가하지 않고 바로 false라는 산출 결과를 낸다. **

    따라서, **&&와 ||가 더 효율적이다.**



- 비트 연산자(&, |, ^, ~, <<. >>, >>>)

  - 비트(bit) 단위로 연산을 한다. 즉 0과 1이 피연산자가 된다.

    - 0과 1로 표현이 가능한 정수 타입만 비트 연산을 할 수 있다.
    - 실수 타입ㅇ인 float와 double은 비트 연산을 할 수 없다.

  - 종류

    - 비트 논리 연산자

      - 피연산자가 boolean타입일 경우 -> 일반 논리 연산자
      - 피연산자가 정수 타입일 경우 비트 논리 연산자

    - 비트 이동 연산자(<<, >>, >>>)

      - 정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행
      - `<< `: 정수 a의 각 비트를 b 만큼 왼쪽으로 이동 (빈자리는 0으로 채워진다.)
      - `>>`: 정수 a의 각 비트를 b 만큼 오른쪽으로 이동 (빈자리는 정수 a의 최상위 부호 비트와 같은 값으로 채워진다.)
      - `>>>`: 정수 a의 각 비트를 b 만큼 오른쪽으로 이동 (빈자리는 0으로 채워진다.)

      

  - 비트 연산자는 피연산자를 int타입으로 자동 타입 변환한 후 연산을 수행한다.

    byte, short, char타입을 비트 논리 연산하면 그 결과는 int 타입이 된다.

    

- 대입 연산자(=, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=)
  - 오른쪽 피연산자의 값을 좌측 피연산자인 변수에 저장
  - 종류
    - 단순 대입 연산자
    - 복합 대입 연산자(정해진 연산을 수행한 후 결과를 변수에 저장)



- 조건 연산식(()? :)

  - 조건식에 따라 콜론(:) 앞 뒤의 피연산자가 선택

    ```
      조건식        ?     값 또는 연산식      :     값 또는 연산식  
    (피연산자1)             (피연산자 2)             (피연산자 3)
    						true일 때             false일 때
    ```

    